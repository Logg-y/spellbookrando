import csv
import random
import enum
import argparse
from binascii import crc32
import sys

ver = "0.1"

class MagicPaths(enum.IntEnum):
	NONE = -1
	FIRE = 0
	AIR = 1
	WATER = 2
	EARTH = 3
	ASTRAL = 4
	DEATH = 5
	NATURE = 6
	BLOOD = 7
	HOLY = 8
	
class MagicSchools(enum.IntEnum):
	UNRESEARCHABLE = -1
	CONJURATION = 0
	ALTERATION = 1
	EVOCATION = 2
	CONSTRUCTION = 3
	ENCHANTMENT = 4	
	THAUMATURGY = 5
	BLOOD = 6
	HOLY = 7
	
COMMUNION_SPELLS = ["976", "977", "1052", "1053", "1124", "1125"]
	
def rollpath(forbid=None, **options):
	while 1:
		c = random.choice(list(MagicPaths))
		if c.value == forbid: continue
		elif c == MagicPaths.BLOOD and not options.get("randomiseblood", True): continue
		elif c == MagicPaths.NONE: continue
		elif c == MagicPaths.HOLY: continue
		return c.value
		
def rollschool(path1, path2, forbid=None, **options):
	isblood = False
	if path1 == MagicPaths.BLOOD or path2 == MagicPaths.BLOOD:
		isblood = True
	if options.get("forcebloodinblood", True) and isblood:
		return MagicSchools.BLOOD
	while 1:
		c = random.choice(list(MagicSchools))
		if c.value == forbid: continue
		elif c == MagicSchools.BLOOD and not options.get("randomiseblood", True): continue
		elif c == MagicSchools.BLOOD and options.get("forcebloodinblood", True) and not isblood: continue
		elif c == MagicSchools.UNRESEARCHABLE: continue
		elif c == MagicSchools.HOLY: continue
		elif c == MagicSchools.CONSTRUCTION and random.random() > options.get("constructionrate", 0.3): continue
		return c.value
	
def randomiser(**options):
	# Set PRNG seed
	if options.get("seed", None) is not None:
		seed = int(options["seed"])
		random.seed(seed)
	else:
		seed = str(random.randint(-214783647, 2147483647))
		random.seed(seed)
	name = options.get("name", None)
	if name is None: name = str(seed).replace("-", "m")
	outputfp = f"SpellbookRandomiser-{name}.dm"
		
	path1overrides = {}
	path2overrides = {}
	schooloverrides = {}
		
	with open(outputfp, "w") as output:
		output.write(f"-- This mod was programmatically generated by SpellbookRandomiser v{ver}\n")
		output.write(f"-- The randomisation seed used was {seed}\n")
		output.write('#modname "SpellbookRandomiser-{}"\n'.format(name))
		output.write("\n")
		output.write('#description "A randomised spellbook, named {} and generated with seed {}"'.format(name, seed))
		output.write("\n")
		
		with open("spells.csv", "rb") as f:
			c = f.read()
			checksum = crc32(c)
		output.write(f"-- The checksum of the datafile csv used was {checksum}\n\n\n")
		
		with open("spells.csv", "r") as f:
			csvr = csv.DictReader(f, delimiter="\t")
			for line in csvr:
				# skip unresearchables and noncastables
				if line["school"] == "-1":
					continue
				if line["school"] == "7": # holy
					continue
				elif line["researchlevel"] == "-1":
					continue
				# if we aren't randomising blood, don't randomise blood
				elif options.get("randomiseblood", True) == False and (line["path1"] == "7" or line["path2"] == "7"):
					continue
				# skip magic duel if requested
				elif options.get("skipmagicduel", True) and line["id"] == "523":
					continue
				# skip communions if requested
				elif options.get("skipcommunions", True) and line["id"] in COMMUNION_SPELLS:
					continue
				elif line["path1"] == "-1":
					continue
				else:
					path1 = int(line["path1"])
					path2 = int(line["path2"])
					school = int(line["school"])
					# roll paths as required, but not if they are holy
					if options.get("randomisepaths", True) and path1 != 8:
						path1 = rollpath(**options)
					if options.get("randomisepaths2", True) and path2 != -1 and path2 != 8:
						path2 = rollpath(forbid=path1, **options)
					if options.get("randomiseschools", True):
						school = rollschool(path1, path2, **options)
						
					# Read any overrides, if any were set
					idint = int(line["id"])
					path1 = path1overrides.get(idint, path1)
					path2 = path2overrides.get(idint, path2)
					school = schooloverrides.get(idint, school)
						
					# special for forcing paired communions
					if options.get("pairedcommunions", True) and line["id"] in COMMUNION_SPELLS:
						# convenient fact about their IDs: the lower numbered one is even
						if int(line["id"]) % 2 == 0:
							path1overrides[int(line["id"])+1] = path1
							path2overrides[int(line["id"])+1] = path2
							schooloverrides[int(line["id"])+1] = school
						else:
							path1overrides[int(line["id"])-1] = path1
							path2overrides[int(line["id"])-1] = path2
							schooloverrides[int(line["id"])-1] = school
					
					fatigue = max(int(line["fatiguecost"]), int(line["gemcost"])*100)
					if line["path1"] == "7":
						fatigue /= options.get("gemsperslave", 2.0)
					if path1 == 7:
						fatigue *= options.get("gemsperslave", 2.0)
						
					# if it cost a gem, don't allow it to be free
					# reinvigoration being the most obvious culprit here
					if int(line["gemcost"]) > 0:
						fatigue = max(100.0, fatigue)
						
					fatigue = int(fatigue)
							
					# Write to the .dm
					output.write(f"#selectspell {idint}\n#path 0 {path1}\n#path 1 {path2}\n#school {school}\n#fatiguecost {fatigue}\n#end\n\n")
	print(f"Finished writing file {outputfp}!")
			
# Stuff to make this usable on a non-CL basis
class Option(object):
	def __init__(self, optname, help="", type=None, default=None):
		self.optname = optname
		self.type = type
		self.help = help
		self.default = default
	def toArgparse(self, parser):
		parser.add_argument(self.optname, help=self.help, type=self.type, default=self.default)
	def askInConsole(self):
		print("\n\n-----------------------")
		s = self.help
		if self.type is bool:
			s += " [y/n]"
		print(s)
		if self.type is bool:
			if self.default:
				print("Default: y")
			else:
				print("Default: n")
		elif self.type in [float, int]:
			print(f"Default: {self.default}")
		else:
			if self.default is None:
				print("Default: <NONE>")
			else:
				print(f"Default: {self.default}")
		valid = False
		print("")
		r = input()
		if r.strip() == "":
			return(self.default)
		if self.type is float:
			try:
				return(float(r))
			except:
				print("Could not convert input to a number. Try again!\n")
				return self.askInConsole()
		if self.type is int:
			try:
				return(int(r))
			except:
				print("Could not convert input to a number. Try again!\n")
				return self.askInConsole()
		if self.type is bool:
			if r.lower() == "y":
				return True
			elif r.lower() == "n":
				return False
			print("Please enter y or n.")
			return self.askInConsole()
		
		else:
			return r
		
	
def main():
	opts = []
	opts.append(Option("-randomisepaths", help="Randomise primary spell requirement paths?", type=bool, default=True))
	opts.append(Option("-randomisepaths2", help="Randomise secondary spell requirement paths?", type=bool, default=True))
	opts.append(Option("-randomiseschools", help="Randomise spell research paths?", type=bool, default=True))
	opts.append(Option("-randomiseblood", help="Include blood spells and the magic school in the randomisation?", type=bool, default=True))
	opts.append(Option("-gemsperslave", help="How many gems is one slave worth?", type=float, default=2.0))
	opts.append(Option("-pairedcommunions", help="Keep the communion/sabbath/chorus pairs together in the same path and research school?", type=bool, default=True))
	opts.append(Option("-skipcommunions", help="Skip randomisation communion/sabbath/chorus spells?", type=bool, default=False))
	opts.append(Option("-skipmagicduel", help="Skip magic duel?", type=bool, default=True))
	opts.append(Option("-forcebloodinblood", help="Put blood spells, and only blood spells, in blood magic research?", type=bool, default=True))
	opts.append(Option("-constructionrate", help="Probability of accepting a spell into Construction (1.0 = 100%, 0.5 = 50%)", type=float, default=0.3))
	opts.append(Option("-name", help="File name (default is the seed)", default=None))
	opts.append(Option("-seed", help="PRNG seed for the randomisation, default is random", default=None))

	if len(sys.argv) > 1:
		parser = argparse.ArgumentParser(prog=f"SpellbookRandomiser v{ver}", description="A randomiser for Dom5 non-modded spells!",
		formatter_class=argparse.ArgumentDefaultsHelpFormatter)
		for opt in opts:
			opt.toArgparse(parser)
		
		parser.add_argument("-run", help="Pass this if you want to run commmand line mode and not be forced into guided interactive!", default=None)
		args = parser.parse_args()
		randomiser(**vars(args))
	else:
		print(f"SpellbookRandomiser v{ver}: A randomiser for Dom5 non-modded spells!")
		print("This program can also be run from command line, pass -h for info.")
		print("Pressing ENTER without writing anything will accept the option's default value.")
		args = {}
		for opt in opts:
			# opt.optname has a leading hyphen
			args[opt.optname[1:]] = opt.askInConsole()
		
		print("Performing randomisation...")
		randomiser(**args)
		print("Complete. Press ENTER to exit.")
		input()
	
if __name__ == "__main__":
	main()